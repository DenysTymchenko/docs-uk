# Композиційні функції {#composables}

<script setup>
import { useMouse } from './mouse'
const { x, y } = useMouse()
</script>

:::tip
Цей розділ передбачає базові знання композиційного API. Якщо ви вивчали Vue лише з опційним API, ви можете встановити налаштування API на композиційний (за допомогою перемикача у верхній частині лівої бічної панелі) і перечитати [основи реактивності](/guide/essentials/reactivity-fundamentals) та розділи по [хуках життєвого циклу](/guide/essentials/lifecycle).
:::

## Що таке композиційна функція? {#what-is-a-composable}

У контексті додатків Vue композиційна функція — це функція, яка використовує композиційний API Vue для інкапсуляції та повторного використання **логіки зі станом**.

Під час створення фронтенд додатків нам часто потрібно повторно використовувати логіку для типових завдань. Наприклад, нам може знадобитися форматування дати в багатьох місцях, тому ми беремо для цього функцію для повторного використання. Ця функція форматування інкапсулює логіку **без стану**: вона приймає деякий вхід і негайно повертає очікуваний результат. Існує багато бібліотек для повторного використання логіки без стану, наприклад [lodash](https://lodash.com/) і [date-fns](https://date-fns.org/), про які ви, можливо, чули.

Навпаки, логіка збереження стану передбачає керування станом, який змінюється з часом. Простим прикладом може бути відстеження поточної позиції миші на сторінці. У реальних сценаріях це також може бути складніша логіка, наприклад жести дотиком або статус підключення до бази даних.

## Приклад відстеження миші {#mouse-tracker-example}

Якби ми реалізували функцію відстеження миші за допомогою композиційного API безпосередньо всередині компонента, це виглядало б наступним чином:

```vue
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const x = ref(0)
const y = ref(0)

function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}

onMounted(() => window.addEventListener('mousemove', update))
onUnmounted(() => window.removeEventListener('mousemove', update))
</script>

<template>Координати миші: {{ x }}, {{ y }}</template>
```

Але що, якщо ми хочемо повторно використовувати ту саму логіку в кількох компонентах? Ми можемо перемістити логіку у зовнішній файл як композиційну функцію:

```js
// mouse.js
import { ref, onMounted, onUnmounted } from 'vue'

// за конвенцією, назви композиційних функцій починаються з "use" (англ. — використовувати)
export function useMouse() {
  // стан, інкапсульований і керований композиційною функцією
  const x = ref(0)
  const y = ref(0)

  // композиційна функція може оновлювати свій керований стан з часом.
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }

  // композиційна функція також може підключитися до свого компонента-власника
  // життєвий цикл для налаштування та демонтажу побічних ефектів.
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))

  // відкрити керований стан як значення, що повертається
  return { x, y }
}
```

І ось як це можна використовувати в компонентах:

```vue
<script setup>
import { useMouse } from './mouse.js'

const { x, y } = useMouse()
</script>

<template>Координати миші: {{ x }}, {{ y }}</template>
```

<div class="demo">
  Координати миші: {{ x }}, {{ y }}
</div>

[Спробуйте в пісочниці](https://play.vuejs.org/#eNqNkrFOhEAQhl9lQgOXEM76cneJhZ2WJprQkGMwmGN2sywchJAYK5/AwqewsKDQe4bljZyFO8TEwgZ2Zv75+X6gcS6lDMoCnZWzzncqlRpy1IXchpRmUigNDRQ53gi+QAuJEhm4wTKzdfCYuyGFtBOUW13lQ82azbTgLUJaL0dbNuRCYyb3kUauAMybOZpj/2Q+TGe+zHv/bDown6brX/rXFTTsCG3r2wP7ttZr2nd858zA6BOqwsQHQfx00hjb4y2xzhYTPacdsLEalpKCdjoVNKOGxuKNsSrOw67eBWc59+pZz3Z/LGTMcB6WSPrkAlAFZbQvkHeGfiCjB7wbR/Ufo3s74rD2NiXxGGqzhUNKsTgEURxfWf11mmskVJ47vItMlOj6J4jFwDvL/9tCDep/uVgfxf+Eoukbh9Q67TdHONDL)

Як ми бачимо, основна логіка залишається ідентичною - все, що нам потрібно було зробити, це перемістити її в зовнішню функцію і повернути стан, який повинен бути відкритий. Так само як і всередині компонента, ви можете використовувати повний діапазон [функцій композиційного API](/api/#композиційний-api) у композиційних функціях. Ту саму функцію `useMouse()` тепер можна використовувати в будь-якому компоненті.

Але крутіша частина композиційних функцій полягає в тому, що ви також можете вкладати їх: одна композиційна функція може викликати одну або кілька інших композиційних функцій. Це дає нам змогу створювати складну логіку за допомогою невеликих ізольованих одиниць, подібно до того, як ми створюємо цілу програму за допомогою компонентів. Ось чому ми вирішили назвати набір API, які роблять можливим цей шаблон композиційним API.

Наприклад, ми можемо витягти логіку додавання та видалення слухача подій DOM у свою власну композиційну функцію:

```js
// event.js
import { onMounted, onUnmounted } from 'vue'

export function useEventListener(target, event, callback) {
  // за бажанням, ви також можете додати 
  // підтримку рядків в якості цілі для прослуховування
  onMounted(() => target.addEventListener(event, callback))
  onUnmounted(() => target.removeEventListener(event, callback))
}
```

І тепер наш `useMouse()` можна спростити до:

```js{3,9-12}
// mouse.js
import { ref } from 'vue'
import { useEventListener } from './event'

export function useMouse() {
  const x = ref(0)
  const y = ref(0)

  useEventListener(window, 'mousemove', (event) => {
    x.value = event.pageX
    y.value = event.pageY
  })

  return { x, y }
}
```

:::tip
Кожен екземпляр компонента, що викликає `useMouse()`, створить власні копії стану `x` і `y`, щоб вони не заважали один одному. Якщо ви хочете керувати спільним станом між компонентами, прочитайте розділ [Керування станом](/guide/scaling-up/state-management).
:::

## Приклад асинхронного стану {#async-state-example}

Композиційна функція `useMouse()` не приймає жодних аргументів, тож подивимося на інший приклад, у якому вона використовується. Під час отримання асинхронних даних нам часто потрібно обробляти різні стани: завантаження, успіх і помилка:

```vue
<script setup>
import { ref } from 'vue'

const data = ref(null)
const error = ref(null)

fetch('...')
  .then((res) => res.json())
  .then((json) => (data.value = json))
  .catch((err) => (error.value = err))
</script>

<template>
  <div v-if="error">Ой! Виникла помилка: {{ error.message }}</div>
  <div v-else-if="data">
    Дані завантажено:
    <pre>{{ data }}</pre>
  </div>
  <div v-else>Завантаження...</div>
</template>
```

Було б утомливо повторювати цей шаблон у кожному компоненті, який потребує отримання даних. Перемістимо його в композиційну функцію:

```js
// fetch.js
import { ref } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  fetch(url)
    .then((res) => res.json())
    .then((json) => (data.value = json))
    .catch((err) => (error.value = err))

  return { data, error }
}
```

Тепер у нашому компоненті ми можемо просто зробити:

```vue
<script setup>
import { useFetch } from './fetch.js'

const { data, error } = useFetch('...')
</script>
```

### Приймання рективного стану {#accepting-reactive-state}

`useFetch()` приймає статичний рядок URL-адреси як вхідні дані, тому він виконує витягнення даних лише один раз, а потім завершує роботу. Що, якщо ми хочемо, щоб він повторно витягував дані щоразу, коли змінюється URL? Ми можемо досягти цього, також приймаючи референції як аргумент:

Для прикладу, `useFetch()` має мати можливість приймати референцію:

```js
const url = ref('/initial-url')

const { data, error } = useFetch(url)

// це має викликати повторне витягування даних
url.value = '/new-url'
```

Або приймати геттер:

```js
// повторно отримати, коли змінюється props.id
const { data, error } = useFetch(() => `/posts/${props.id}`)
```

Ми можемо змінити нашу існуючу реалізацію за допомогою API [`watchEffect()`](/api/reactivity-core.html#watcheffect) і [`toValue()`](/api/reactivity-utilities.html#tovalue):

```js{8,13}
// fetch.js
import { ref, watchEffect, toValue } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  watchEffect(() => {
    // скидання стану перед отриманням..
    data.value = null
    error.value = null
    // toValue() розгортає потенційні референції або геттери
    fetch(toValue(url))
      .then((res) => res.json())
      .then((json) => (data.value = json))
      .catch((err) => (error.value = err))
  })

  return { data, error }
}
```

`toValue()` — API, доданий у версії 3.3. Він призначений для нормалізації посилань або геттерів у значення. Якщо аргумент є посиланням, він повертає значення посилання; якщо аргумент є функцією, він її викличе та поверне її значення. В іншому випадку аргумент повертає самого себе. Він працює подібно до [`unref()`](/api/reactivity-utilities.html#unref), але з особливою обробкою функцій.

Зверніть увагу, що `toValue(url)` викликається **всередині** зворотного виклику `watchEffect`. Це гарантує, що спостерігач відстежує будь-які реактивні залежності, до яких звертаються під час нормалізації `toValue()`.

Ця версія `useFetch()` тепер приймає статичні рядки URL-адрес, посилання та геттери, що робить її набагато гнучкішою. Ефект спостереження запуститься негайно та відстежуватиме будь-які залежності, доступ до яких здійснюється під час `toValue(url)`. Якщо жодні залежності не відстежуються (наприклад, URL-адреса вже є рядком), ефект запускається лише один раз; інакше він запускатиметься повторно щоразу, коли відстежувана залежність зміниться.

Ось [оновлена версія `useFetch()`](https://play.vuejs.org/#eNqFVd1O40YUfpVT38SoWZsK9QYF1B9RqVV/VnS3V77xOhNi1rEtexxAUaQttNutVBWpqti7Sn2CpogsKSXwCuM32u/M2CaBaFeQxHPm/HznO9+MR9anaeoMC2FtWp08yMJUUi5kkW57cThIk0zSiDLRa1OQDNJCii6NqZclA2ohqLXgVOTiCyGDfrPvuLXJ2c/h6cVBEueSnvm5eJpFtEWtvpRpvum6+3kSp5EfiH4SdUXmyKM0DJKucFDUlUk3yV0kMOFhF5FAZLc+aq3VxkLnqyHa9hptbTeFPkSMM/SjQsC/jhhR15d+m0SWJVkbCWV2BOhbTR82csK/4xpWwAcWUgyAUwqsiNRrNVHn+MzLY3y/UTP8zqj8kZflMf5+J3VJaq5u1LWali/4d5MjO88KKZOYho96SbblWSGFMX3sWfRJEIXBc7Zwl6FnbY9GFNJ43HFNiIbhyU43HCI67MFVdwBPTozU6bb6S/33Aak/1AylZ+pK/a8mpG41ihkWV2qyScirA52ByHN/T+gaPHWdpMLXwNH0oIb6W93qPv4tT7h10/CvakqwTtTlAkxkcYHSPBm4IsqFwczcc7r7DE6ZLFIX2nS2iW4ywRSwv0GI9cq8q3PNy1PHceqAjtvMz2pbC+qE+JfFfuBjY6fXE4Fsk0x+YPHcE74Xi0Md0iviQIZga0k5NGKARmsavRFtXESsqnpHj+D+Fn8WANh+fhQHZDStsxK5LmSGQc4MVdxnpTs8nvCwWW5TdUHqBjp8Acfr2lFdO47JwrjMwQAELm/MRhcP7YulIa3yZ60E5OSRncN0icdJ+Ut1DpplNQh6uvv1I4C4YGScos3KgZQ4mPNwlvIM+9zIVL0xEoNgb2BBf6fqivwGBNLzHvxYKhxT/lYlWGJPU1rzjcmYWW7VU62O+V1/fA9ULJtmXyHzCdpAM7powyfOkav7vuWusLxhvPdOmh6oJPIP/FCSDAciKSpQbOZG/lFXTASVL805mpY/VeObly/R2imIOsZ+EbNM1kyBc+0yR8QDnlekeM2XRt3QGfuj5qtVwfpkX/DOQhX0zwD0BMo/K7akoTQTOdg07fVq+Wtq+bbVRZd0ZjwRhXOXxPV4xhTwzMgW1cl5KERRefLPWN/kxNd2kcXLlzl74N+L3zc8L26ObjMXU7xKG4sDeowjH+bCtoE4iYaCXxX70NXiacQL80mVYOmUEoU9sr/xZd/J/LibDLC7TevOxkKPXEwnrplgLvhCW3bhkjbj2eEW7dauzmdWrbW70IqjNm2sr2srMzXGbSdzjKsX7mnWcd/p7J7Fr8wwEtl3KfOQexbeDNV8LT+KkoOvtE1mhWjX9qAvgucr7Pv5Ids86zFaEtlQeFazJ/1sT0izvfP9t+IQz83mIOkWEbzfsbnLJBWM0bh9VsRdwF7w02i/1Ld4GO89yXcOpYjzuikGqunQ/p6FO/zzd7R+B3fD2dBxzOL4LWfa5SM=) зі штучною затримкою та рандомізовано помилка для демонстраційних цілей.

## Конвенції та найкращі практики {#conventions-and-best-practices}

### Іменування {#naming}

Визначає правило іменування композиційних функцій за допомогою імен верблюжого регістру, які починаються з "use".

### Вхідні аргументи {#input-arguments}

Композиційна функція може приймати референції або геттери в якості аргументів, навіть якщо вона не покладається на них для реактивності. Якщо ви пишете композиційну функцію, яка може використовуватися іншими розробниками, буде гарною ідеєю розглянути випадок, коли вхідні аргументи є референціями або геттерами замість необроблених значень. Допоміжна функція [`toValue()`](/api/reactivity-utilities#tovalue) стане в пригоді для цієї мети:

```js
import { toValue } from 'vue'

function useFeature(maybeRefOrGetter) {
  // якщо maybeRefOrGetter справді є референцією або геттером,
  // буде повернено його нормалізоване значення.
  // Інакше воно буде повернуте як є
  const value = toValue(maybeRefOrGetter)
}
```

Якщо ваша композиційна функція створює реактивні ефекти, коли вхідний аргумент є референцією або геттером, переконайтеся, що ви явно спостерігаєте за посиланням / геттером за допомогою `watch()`, або викликаєте `toValue()` всередині `watchEffect()`, щоб воно належним чином відстежувалося.

[Реалізація useFetch(), розглянута раніше](#accepting-reactive-state) надає конкретний приклад компонованого, який приймає посилання, геттери та звичайні значення як вхідний аргумент.

### Повернуті значення {#return-values}

Ви, мабуть, помітили, що ми використовували виключно `ref()` замість `reactive()` у композиційних функціях. Згідно з конвенцією, рекомендується, щоб композиційні функції завжди повертали звичайний нереактивний об’єкт, що містить кілька референцій. Це дозволяє його деструктурувати на компоненти, зберігаючи реакційну здатність:

```js
// x і y є референціями
const { x, y } = useMouse()
```

Повернення реактивного об'єкта з композиційної функції призведе до того, що такі деструктуризовані дані втратять зв'язок реактивності зі станом всередині композиційної функції, тоді як референції збережуть цей зв'язок.

Якщо ви віддаєте перевагу використанню повернутого стану від композиційної функції як властивості об'єкта, ви можете обгорнути повернутий об'єкт за допомогою `reactive()`, щоб референції були розгорнутими. Наприклад:

```js
const mouse = reactive(useMouse())
// mouse.x пов'язано з оригінальною референцією
console.log(mouse.x)
```

```vue-html
Координати миші: {{ mouse.x }}, {{ mouse.y }}
```

### Сторонні ефекти {#side-effects}

Виконувати побічні ефекти (наприклад, додавати прослуховувачі подій DOM або отримувати дані) у композиційних функціях можна, але зверніть увагу на наступні правила:

- Якщо ви працюєте над програмою, яка використовує [рендеринг на стороні сервера](/guide/scaling-up/ssr) (SSR), переконайтеся, що ви виконуєте специфічні для DOM побічні ефекти в хуках життєвого циклу після монтування, наприклад, `onMounted()`. Ці хуки викликаються лише в браузері, тож ви можете бути впевнені, що код у них має доступ до DOM.

- Не забудьте очищувати побічні ефекти в `onUnmounted()`. Наприклад, якщо композиційна функція встановлює слухач подій DOM, він повинен видалити цей слухач у `onUnmounted()`, як ми бачили у прикладі `useMouse()`. Гарною ідеєю може бути використання композиційної функції, яка автоматично робить це за вас, як-от приклад `useEventListener()`.

### Обмеження при використанні {#usage-restrictions}

Composables слід викликати лише в `<script setup>` або `setup()`. У цьому контексті їх також слід називати **синхронно**. У деяких випадках ви також можете викликати їх у хуках життєвого циклу, наприклад `onMounted()`.

Ці обмеження важливі, оскільки це контексти, де Vue може визначити поточний активний екземпляр компонента. Доступ до екземпляра активного компонента необхідний для того, щоб:

1. В ньому можна зареєструвати хуки життєвого циклу.

2. До нього можна прив'язати обчислювані властивості та спостерігачі, щоб їх можна було видалити, коли екземпляр відмонтовано, щоб запобігти джерелам витоку пам'яті.

:::tip
`<script setup>` є єдиним місцем, де ви можете викликати композиційні функції **після** використання `await`. Компілятор автоматично відновлює для вас активний контекст екземпляра після асинхронної операції.
:::

## Витягнення композиційних функцій для організації коду {#extracting-composables-for-code-organization}

Композиційні функції можна витягати не тільки для повторного використання, але й для організації коду. У міру того, як складність ваших компонентів зростає, ви можете опинитися з надто великими компонентами для навігації та розуміння. Композиційний API дає вам повну гнучкість для організації коду компонента в менші функції на основі логічних проблем:

```vue
<script setup>
import { useFeatureA } from './featureA.js'
import { useFeatureB } from './featureB.js'
import { useFeatureC } from './featureC.js'

const { foo, bar } = useFeatureA()
const { baz } = useFeatureB(foo)
const { qux } = useFeatureC(baz)
</script>
```

Певною мірою ви можете розглядати ці витягнуті компоненти як компонентні сервіси, які можуть спілкуватися один з одним.

## Використання композиційних функцій в опційному API {#using-composables-in-options-api}

Якщо ви використовуєте опційний API, композиційні функції потрібно викликати всередині `setup()`, а повернуті прив'язки мають бути повернуті з `setup()` для доступності для `this` і шаблону:

```js
import { useMouse } from './mouse.js'
import { useFetch } from './fetch.js'

export default {
  setup() {
    const { x, y } = useMouse()
    const { data, error } = useFetch('...')
    return { x, y, data, error }
  },
  mounted() {
    // Доступ до відкритих властивостей setup() можна отримати через `this`
    console.log(this.x)
  }
  // ...інші варіанти
}
```

## Порівняння щодо інших технік {#comparisons-with-other-techniques}

### щодо міксинів {#vs-mixins}

Користувачі, які перейшли з Vue 2, можуть бути знайомі з параметром [mixins](/api/options-composition#mixins), який також дозволяє нам витягувати логіку компонентів у багаторазові блоки. У міксинів є три основні недоліки:

1. **Незрозуміле джерело властивостей**: при використанні багатьох міксинів стає незрозуміло, яка властивість екземпляра впроваджується яким міксином, що ускладнює відстеження реалізації та розуміння поведінки компонента. Ось чому ми також рекомендуємо використовувати шаблон "референція + деструктуризація" для композиційних функцій: це робить джерело властивості зрозумілим у споживаючих компонентах.

2. **Колізії просторів імен**: кілька міксинів від різних авторів потенційно можуть зареєструвати однакові ключі властивостей, спричиняючи колізії просторів імен. За допомогою композиційниї функцій ви можете перейменувати деструктуровані змінні, якщо є конфліктні ключі від різних композиційних функцій.

3. **Неявний зв'язок крос-міксинів**: кілька міксинів, які повинні взаємодіяти один з одним, повинні покладатися на спільні ключі властивостей, що робить їх неявно зв'язаними. За допомогою композиційних функцій значення, повернуті однією композиційною функцією, можна передати в інший як аргументи, як і у звичайні функції.

З наведених вище причин ми більше не рекомендуємо використовувати міксини у Vue 3. Ця функція зберігається лише з міркувань міграції та знайомства.

### щодо компонентів без рендерингу {#vs-renderless-components}

У розділі про слоти компонентів ми обговорили шаблон [компоненти без рендеру](/guide/components/slots#renderless-components) на основі слотів з обмеженою областю. Ми навіть реалізували ту саму демонстрацію відстеження миші, використовуючи компоненти без рендерингу.

Основна перевага складових компонентів над компонентами без рендерингу полягає в тому, що складові компоненти не спричиняють додаткових витрат на екземпляр компонента. При використанні в усій програмі, кількість додаткових екземплярів компонентів, створених за допомогою шаблону компонента без рендерингу, може призвести до помітних накладних витрат на продуктивність.

Рекомендується використовувати композиційні функції при повторному використанні чистої логіки та використовувати компоненти при повторному використанні як логіки, так і візуального макета.

### щодо React хуків {#vs-react-hooks}

Якщо у вас є досвід роботи з React, ви можете помітити, що це дуже схоже на спеціальні хуки React. Композиційний API був частково натхненний хуками React, і композиційні функції Vue справді схожі на хуки React з точки зору можливостей логічної композиції. Однак, композиційні функції Vue базуються на багатогранній системі реактивності Vue, яка принципово відрізняється від моделі виконання хуків React. Це обговорюється більш детально в [поширених питаннях щодо композиційного API](/guide/extras/composition-api-faq#comparison-with-react-hooks).

## Подальше читання {#further-reading}

- [Реактивність поглиблено](/guide/extras/reactivity-in-depth): для низькорівневого розуміння того, як працює система реактивності Vue.
- [Керування станом](/guide/scaling-up/state-management): для шаблонів керування станом, спільного для кількох компонентів.
- [Тестування композиційниї функцій](/guide/scaling-up/testing#testing-composables): поради щодо модульного тестування композиційних функцій.
- [VueUse](https://vueuse.org/): колекція Vue композиційних функцій, постійно покращується. Вихідний код також є чудовим навчальним ресурсом.
